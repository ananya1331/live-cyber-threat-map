<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Cyber Threat Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: #ffffff;
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #333;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }

        .stats {
            display: flex;
            gap: 30px;
            font-size: 14px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #aaa;
            margin-top: 2px;
        }

        #map {
            height: 100vh;
            width: 100%;
            background: #0a0a0a;
        }

        .attack-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 350px;
            height: calc(100vh - 100px);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ff6b6b;
            text-align: center;
        }

        .attack-list {
            flex: 1;
            overflow-y: auto;
        }

        .attack-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid;
            animation: slideIn 0.3s ease;
        }

        .attack-item.high { border-left-color: #ff4757; }
        .attack-item.medium { border-left-color: #ffa726; }
        .attack-item.low { border-left-color: #66bb6a; }

        .attack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .attack-type {
            font-weight: bold;
            font-size: 14px;
        }

        .attack-intensity {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .attack-route {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }

        .attack-time {
            font-size: 11px;
            color: #888;
            margin-top: 3px;
        }

        .connection-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 1000;
        }

        .connected {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border: 1px solid #4caf50;
        }

        .disconnected {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }

        .legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 1000;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #ff6b6b;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border-radius: 2px;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .attack-marker {
            animation: pulse 2s infinite;
        }

        /* Scrollbar styling */
        .attack-list::-webkit-scrollbar {
            width: 6px;
        }

        .attack-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .attack-list::-webkit-scrollbar-thumb {
            background: rgba(255, 107, 107, 0.5);
            border-radius: 3px;
        }

        .attack-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 107, 107, 0.7);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">üåê CyberThreat Live Map</div>
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="totalAttacks">0</div>
                <div class="stat-label">Total Attacks</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="activeConnections">0</div>
                <div class="stat-label">Active Monitors</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="attacksPerMin">0</div>
                <div class="stat-label">Attacks/Min</div>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <div class="attack-panel">
        <div class="panel-title">üö® Live Attack Feed</div>
        <div class="attack-list" id="attackList"></div>
    </div>

    <div class="connection-status" id="connectionStatus">
        <span id="statusText">Connecting...</span>
    </div>

    <div class="legend">
        <div class="legend-title">Attack Intensity</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #66bb6a;"></div>
            <span>Low (1-3)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ffa726;"></div>
            <span>Medium (4-7)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff4757;"></div>
            <span>High (8-10)</span>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        class DDoSMap {
            constructor() {
                this.map = null;
                this.ws = null;
                this.attacks = new Map();
                this.attackLines = new Map();
                this.stats = {
                    totalAttacks: 0,
                    activeConnections: 0,
                    attacksPerMin: 0
                };
                this.attacksThisMinute = 0;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.init();
            }

            init() {
                this.initMap();
                this.connectWebSocket();
                this.startStatsUpdate();
            }

            initMap() {
                // Initialize map with dark theme
                this.map = L.map('map', {
                    center: [30, 0],
                    zoom: 2,
                    zoomControl: false,
                    attributionControl: false
                });

                // Use OpenStreetMap tiles (free alternative)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                    attribution: ''
                }).addTo(this.map);

                // Apply dark filter to make it look cyber-themed
                const mapContainer = document.getElementById('map');
                mapContainer.style.filter = 'invert(1) hue-rotate(180deg) brightness(0.8) contrast(1.2)';

                // Custom zoom control
                L.control.zoom({ position: 'bottomleft' }).addTo(this.map);
            }

            connectWebSocket() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    return; // Already connected
                }

                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                console.log("Attempting WebSocket connection to:", wsUrl);
                this.updateConnectionStatus(false, "Connecting...");

                try {
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log("‚úÖ WebSocket connected");
                        this.updateConnectionStatus(true);
                        this.reconnectAttempts = 0;
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            console.log("üì® WebSocket message:", message);
                            this.handleMessage(message);
                        } catch (e) {
                            console.error("Error parsing WebSocket message:", e);
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error("‚ùå WebSocket error:", error);
                        this.updateConnectionStatus(false, "Connection Error");
                    };

                    this.ws.onclose = (event) => {
                        console.warn("üîå WebSocket closed:", event.code, event.reason);
                        this.updateConnectionStatus(false, "Disconnected");
                        
                        // Attempt to reconnect
                        if (this.reconnectAttempts < this.maxReconnectAttempts) {
                            this.reconnectAttempts++;
                            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
                            console.log(`üîÑ Reconnecting in ${delay}ms... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                            setTimeout(() => this.connectWebSocket(), delay);
                        } else {
                            this.updateConnectionStatus(false, "Connection Failed");
                        }
                    };

                } catch (error) {
                    console.error("üí• Failed to create WebSocket:", error);
                    this.updateConnectionStatus(false, "Connection Failed");
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'attack':
                        this.addAttack(message.data);
                        break;
                    case 'stats':
                        this.updateStats(message.data);
                        break;
                    case 'welcome':
                        console.log("üéâ Welcome message:", message.data.message);
                        break;
                    default:
                        console.log("Unknown message type:", message.type);
                }
            }

            addAttack(attackData) {
                const attack = {
                    ...attackData,
                    timestamp: new Date(attackData.timestamp)
                };

                // Add to map
                this.addAttackToMap(attack);
                
                // Add to attack list
                this.addAttackToList(attack);
                
                // Update stats
                this.stats.totalAttacks++;
                this.attacksThisMinute++;
                this.updateStatsDisplay();

                // Store attack
                this.attacks.set(attack.id, attack);

                // Clean up old attacks (keep only last 1000)
                if (this.attacks.size > 1000) {
                    const oldestId = this.attacks.keys().next().value;
                    this.removeAttack(oldestId);
                }
            }

            addAttackToMap(attack) {
                // Create attack line from source to target
                const latlngs = [
                    [attack.source_lat, attack.source_lng],
                    [attack.target_lat, attack.target_lng]
                ];

                const intensity = attack.intensity;
                let color = '#66bb6a'; // Low - green
                if (intensity >= 8) color = '#ff4757'; // High - red
                else if (intensity >= 4) color = '#ffa726'; // Medium - orange

                const line = L.polyline(latlngs, {
                    color: color,
                    weight: Math.max(2, intensity / 2),
                    opacity: 0.8,
                    dashArray: '5, 10'
                }).addTo(this.map);

                // Add source marker (attacker)
                const sourceMarker = L.circleMarker([attack.source_lat, attack.source_lng], {
                    radius: Math.max(6, intensity),
                    fillColor: color,
                    color: '#fff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8,
                    className: 'attack-marker'
                }).addTo(this.map);

                // Add target marker (victim)
                const targetMarker = L.circleMarker([attack.target_lat, attack.target_lng], {
                    radius: 4,
                    fillColor: '#ff6b6b',
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.6
                }).addTo(this.map);

                // Add popup with attack details
                const popupContent = `
                    <div style="color: #333; font-family: Arial, sans-serif;">
                        <strong>${attack.attack_type}</strong><br>
                        <strong>From:</strong> ${attack.source_country}<br>
                        <strong>To:</strong> ${attack.target_country}<br>
                        <strong>Intensity:</strong> ${attack.intensity}/10<br>
                        <strong>Time:</strong> ${attack.timestamp.toLocaleTimeString()}
                    </div>
                `;
                
                line.bindPopup(popupContent);
                sourceMarker.bindPopup(popupContent);
                targetMarker.bindPopup(popupContent);

                this.attackLines.set(attack.id, { line, sourceMarker, targetMarker });

                // Remove after 30 seconds
                setTimeout(() => {
                    this.removeAttackFromMap(attack.id);
                }, 30000);
            }

            removeAttackFromMap(attackId) {
                const elements = this.attackLines.get(attackId);
                if (elements) {
                    this.map.removeLayer(elements.line);
                    this.map.removeLayer(elements.sourceMarker);
                    this.map.removeLayer(elements.targetMarker);
                    this.attackLines.delete(attackId);
                }
            }

            addAttackToList(attack) {
                const attackList = document.getElementById('attackList');
                
                const intensity = attack.intensity;
                let intensityClass = 'low';
                if (intensity >= 8) intensityClass = 'high';
                else if (intensity >= 4) intensityClass = 'medium';

                const attackItem = document.createElement('div');
                attackItem.className = `attack-item ${intensityClass}`;
                attackItem.innerHTML = `
                    <div class="attack-header">
                        <div class="attack-type">${attack.attack_type}</div>
                        <div class="attack-intensity">${intensity}/10</div>
                    </div>
                    <div class="attack-route">
                        ${attack.source_country} ‚Üí ${attack.target_country}
                    </div>
                    <div class="attack-time">
                        ${attack.timestamp.toLocaleTimeString()}
                    </div>
                `;

                attackList.insertBefore(attackItem, attackList.firstChild);

                // Keep only last 50 attacks in the list
                while (attackList.children.length > 50) {
                    attackList.removeChild(attackList.lastChild);
                }
            }

            removeAttack(attackId) {
                this.attacks.delete(attackId);
                this.removeAttackFromMap(attackId);
            }

            updateStats(statsData) {
                this.stats.activeConnections = statsData.active_connections || 0;
                this.updateStatsDisplay();
            }

            updateStatsDisplay() {
                document.getElementById('totalAttacks').textContent = this.stats.totalAttacks.toLocaleString();
                document.getElementById('activeConnections').textContent = this.stats.activeConnections;
                document.getElementById('attacksPerMin').textContent = this.stats.attacksPerMin;
            }

            updateConnectionStatus(connected, customMessage = null) {
                const statusElement = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (connected) {
                    statusElement.className = 'connection-status connected';
                    statusText.textContent = customMessage || 'üü¢ Connected';
                } else {
                    statusElement.className = 'connection-status disconnected';
                    statusText.textContent = customMessage || 'üî¥ Disconnected';
                }
            }

            startStatsUpdate() {
                // Update attacks per minute every minute
                setInterval(() => {
                    this.stats.attacksPerMin = this.attacksThisMinute;
                    this.attacksThisMinute = 0;
                    this.updateStatsDisplay();
                }, 60000);

                // Update display every second
                setInterval(() => {
                    this.updateStatsDisplay();
                }, 1000);
            }
        }

        // Initialize the map when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Initializing DDoS Attack Map...');
            new DDoSMap();
        });

        // Add some CSS animations for the markers
        const style = document.createElement('style');
        style.textContent = `
            .leaflet-marker-icon {
                animation: pulse 2s infinite;
            }
            
            @keyframes attackLine {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0.8; }
            }
            
            .leaflet-interactive {
                animation: attackLine 0.5s ease-in-out;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>